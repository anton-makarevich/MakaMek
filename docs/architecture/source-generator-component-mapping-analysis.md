# Source Generator for Component-to-Definition Mapping - Feasibility Analysis

## Executive Summary

**Verdict: HIGHLY FEASIBLE** ✅

A source generator can successfully automate the mapping between `MakaMekComponent` enum values and their corresponding Component types. The WeaponDefinition edge case (one definition type creating both Weapon and Ammo components) is **not a blocker** and can be elegantly handled through the existing architecture.

## Current State Analysis

### Manual Mapping Problem

The `ClassicBattletechComponentProvider` currently contains **two large manual dictionaries** that must be updated every time a new component is added:

1. **`_definitions` Dictionary** (lines 44-99): Maps `MakaMekComponent` → `ComponentDefinition`
   - 48 manual entries
   - Uses static `Definition` properties from component classes
   - Special handling for Ammo (uses `Ammo.CreateAmmoDefinition()`)
   - Special handling for Engine (dynamic definition based on state)

2. **`_factories` Dictionary** (lines 104-162): Maps `MakaMekComponent` → Factory function
   - 48 manual entries
   - Creates component instances via constructors
   - All accept `ComponentData?` parameter

### Current Architecture Patterns

All component classes follow a **consistent pattern**:

```csharp
public sealed class SmallLaser(ComponentData? componentData = null) 
    : Weapon(Definition, componentData)
{
    public static readonly WeaponDefinition Definition = new(
        Name: "Small Laser",
        // ... properties ...
        WeaponComponentType: MakaMekComponent.SmallLaser);
}
```

**Key observations:**
- Every component class has a static `Definition` property
- Every component class has a constructor accepting `ComponentData?`
- The `Definition.ComponentType` property links back to the `MakaMekComponent` enum
- This creates a **bidirectional mapping** that can be discovered via reflection

### The WeaponDefinition "Edge Case"

`WeaponDefinition` is used by:
- **Weapon classes** (e.g., `MachineGun`, `AC20`) - use `WeaponComponentType` property
- **Ammo class** - uses `AmmoComponentType` property from the weapon's definition

**Current handling:**
```csharp
// Definitions
[MakaMekComponent.MachineGun] = MachineGun.Definition,
[MakaMekComponent.ISAmmoMG] = Ammo.CreateAmmoDefinition(MachineGun.Definition),

// Factories
[MakaMekComponent.MachineGun] = data => new MachineGun(data),
[MakaMekComponent.ISAmmoMG] = data => new Ammo(MachineGun.Definition, data),
```

**Why this is NOT a problem:**
1. Each `MakaMekComponent` enum value still maps to exactly ONE component type
2. Ammo is a separate class with its own factory logic
3. The `WeaponDefinition.AmmoComponentType` property already encodes the relationship
4. The source generator can discover this relationship through the static `Definition` property

## Proposed Source Generator Design

### 1. Discovery Strategy

The generator will scan for classes that:
- Inherit from `Component` (directly or indirectly)
- Have a public static property named `Definition` of type `ComponentDefinition` (or derived types)
- Are not abstract

For each discovered class:
- Extract the `ComponentType` from the static `Definition` property
- Verify the class has a constructor accepting `ComponentData?`
- Generate mapping entries

### 2. Special Case Handling

#### Engine (Dynamic Definition)
**Current:** Definition is created dynamically based on `EngineStateData`

**Solution:** Keep the special case in the provider:
```csharp
public ComponentDefinition? GetDefinition(MakaMekComponent componentType, ComponentSpecificData? specificData = null)
{
    if (componentType == MakaMekComponent.Engine && specificData is EngineStateData engineState)
    {
        return Engine.CreateEngineDefinition(engineState);
    }
    return _generatedDefinitions.GetValueOrDefault(componentType);
}
```

The generator will **skip** Engine in the definitions dictionary but **include** it in the factories dictionary.

#### Ammo (Derived from WeaponDefinition)
**Current:** Uses `Ammo.CreateAmmoDefinition(weaponDef)` and `new Ammo(weaponDef, data)`

**Solution:** The generator can detect ammo types by:
1. Finding all `WeaponDefinition` instances with non-null `AmmoComponentType`
2. Generating entries that reference the weapon's definition:

```csharp
// Generated code
[MakaMekComponent.ISAmmoMG] = Ammo.CreateAmmoDefinition(MachineGun.Definition),
[MakaMekComponent.ISAmmoMG] = data => new Ammo(MachineGun.Definition, data),
```

### 3. Generated Code Structure

The generator will create a partial class extension:

```csharp
// <auto-generated/>
using Sanet.MakaMek.Core.Data.Units.Components;
using Sanet.MakaMek.Core.Models.Units.Components;
// ... all component namespaces ...

namespace Sanet.MakaMek.Core.Models.Game.Rules
{
    /// <summary>
    /// Auto-generated component mappings
    /// Generated by ComponentProviderGenerator
    /// </summary>
    public partial class ClassicBattletechComponentProvider
    {
        partial void InitializeGeneratedDefinitions(
            Dictionary<MakaMekComponent, ComponentDefinition> definitions)
        {
            // Actuators
            definitions[MakaMekComponent.Shoulder] = ShoulderActuator.Definition;
            definitions[MakaMekComponent.UpperArmActuator] = UpperArmActuator.Definition;
            // ... all components except Engine ...
            
            // Ammo (using weapon definitions)
            definitions[MakaMekComponent.ISAmmoMG] = Ammo.CreateAmmoDefinition(MachineGun.Definition);
            // ... all ammo types ...
        }

        partial void InitializeGeneratedFactories(
            Dictionary<MakaMekComponent, Func<ComponentData?, Component?>> factories)
        {
            // Actuators
            factories[MakaMekComponent.Shoulder] = data => new ShoulderActuator(data);
            factories[MakaMekComponent.UpperArmActuator] = data => new UpperArmActuator(data);
            // ... all components including Engine ...
            
            // Ammo
            factories[MakaMekComponent.ISAmmoMG] = data => new Ammo(MachineGun.Definition, data);
            // ... all ammo types ...
        }
    }
}
```

### 4. Provider Class Modifications

The `ClassicBattletechComponentProvider` will be modified to:

```csharp
public partial class ClassicBattletechComponentProvider : IComponentProvider
{
    private readonly Dictionary<MakaMekComponent, ComponentDefinition> _definitions;
    private readonly Dictionary<MakaMekComponent, Func<ComponentData?, Component?>> _factories;

    public ClassicBattletechComponentProvider()
    {
        _definitions = new Dictionary<MakaMekComponent, ComponentDefinition>();
        _factories = new Dictionary<MakaMekComponent, Func<ComponentData?, Component?>>();
        
        // Generated method will populate these
        InitializeGeneratedDefinitions(_definitions);
        InitializeGeneratedFactories(_factories);
    }

    // Partial methods implemented by source generator
    partial void InitializeGeneratedDefinitions(
        Dictionary<MakaMekComponent, ComponentDefinition> definitions);
    partial void InitializeGeneratedFactories(
        Dictionary<MakaMekComponent, Func<ComponentData?, Component?>> factories);

    public ComponentDefinition? GetDefinition(MakaMekComponent componentType, ComponentSpecificData? specificData = null)
    {
        // Special case for Engine (dynamic definition)
        if (componentType == MakaMekComponent.Engine && specificData is EngineStateData engineState)
        {
            return Engine.CreateEngineDefinition(engineState);
        }
        return _definitions.GetValueOrDefault(componentType);
    }

    public Component? CreateComponent(MakaMekComponent componentType, ComponentData? componentData = null)
    {
        return _factories.TryGetValue(componentType, out var factory) ? factory(componentData) : null;
    }
}
```

## Implementation Plan

### Phase 1: Generator Infrastructure (2-3 hours)
1. Create `ComponentProviderGenerator.cs` in `MakaMek.SourceGenerators` project
2. Implement incremental generator pattern (following existing generators)
3. Set up syntax provider to find Component-derived classes
4. Implement semantic analysis to extract:
   - Class name and full namespace
   - Static `Definition` property and its type
   - Constructor signature validation

### Phase 2: Ammo Detection Logic (1-2 hours)
1. Scan all `WeaponDefinition` instances for `AmmoComponentType` property
2. Build mapping of ammo component types to their weapon definitions
3. Generate special factory code for ammo components

### Phase 3: Code Generation (2-3 hours)
1. Generate `InitializeGeneratedDefinitions` method
   - Skip Engine (handled manually)
   - Include all other components
   - Include ammo using `Ammo.CreateAmmoDefinition()`
2. Generate `InitializeGeneratedFactories` method
   - Include all components (including Engine)
   - Include ammo with weapon definition parameter
3. Add proper using statements for all component namespaces
4. Add XML documentation

### Phase 4: Provider Refactoring (1 hour)
1. Convert `ClassicBattletechComponentProvider` to partial class
2. Remove manual `InitializeDefinitions()` and `InitializeFactories()` methods
3. Add partial method declarations
4. Update constructor to call partial methods
5. Keep Engine special case in `GetDefinition()`

### Phase 5: Testing & Validation (2-3 hours)
1. Verify all 48 components are correctly mapped
2. Test Engine special case still works
3. Test Ammo creation for all weapon types
4. Add unit tests for the generator itself
5. Verify build performance (incremental generation)

### Phase 6: Documentation (1 hour)
1. Update architecture documentation
2. Add comments explaining the generation process
3. Document how to add new components (just create the class with Definition property)

**Total Estimated Time: 9-13 hours**

## Benefits

1. **Eliminates Manual Updates**: Adding a new component only requires creating the component class with a static `Definition` property
2. **Type Safety**: Compiler errors if component class doesn't follow the pattern
3. **Consistency**: All components are guaranteed to be registered
4. **Discoverability**: Easy to see all components by looking at the enum
5. **Maintainability**: Single source of truth (the component classes themselves)
6. **Build-Time Validation**: Missing components detected at compile time

## Risks & Mitigations

| Risk | Mitigation |
|------|------------|
| Generator complexity | Follow existing generator patterns in the codebase |
| Build time impact | Use incremental generation (only regenerate when component classes change) |
| Debugging difficulty | Generate readable code with comments; add diagnostic output |
| Edge cases not covered | Comprehensive testing; keep manual override capability |

## Alternative Approaches Considered

### 1. Reflection at Runtime
**Rejected:** Performance overhead, no compile-time validation

### 2. Attributes on Component Classes
**Rejected:** Unnecessary - the static `Definition` property already contains all needed information

### 3. Manual Registration with Validation
**Rejected:** Still requires manual updates; only adds validation, doesn't eliminate the problem

## Conclusion

The source generator approach is **highly recommended**. The architecture is already well-suited for this pattern, with consistent conventions across all component classes. The WeaponDefinition edge case is easily handled through the existing `AmmoComponentType` property. The implementation is straightforward, following patterns already established in the codebase's existing generators.

**Next Steps:**
1. Get approval for the approach
2. Implement Phase 1-3 (core generator)
3. Test with existing components
4. Refactor provider (Phase 4)
5. Complete testing and documentation

