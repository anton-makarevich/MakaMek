# Component Mapping Source Generator - Executive Summary

## Quick Answer

**YES, it's highly feasible!** ✅

A source generator can automate the component-to-definition mapping in `ClassicBattletechComponentProvider`, eliminating 150+ lines of manual dictionary initialization that must be updated every time a new component is added.

## The Problem

Currently, `ClassicBattletechComponentProvider.cs` contains two large manual dictionaries:
- **48 entries** in `_definitions` dictionary (lines 44-99)
- **48 entries** in `_factories` dictionary (lines 104-162)

Every new component requires manual updates to both dictionaries, which is:
- ❌ Error-prone (easy to forget)
- ❌ Tedious (repetitive boilerplate)
- ❌ Not validated at compile-time

## The Solution

Use a source generator to automatically discover component classes and generate the mappings at build time.

### How It Works

1. **Discovery**: Scan for classes inheriting from `Component` with a static `Definition` property
2. **Analysis**: Extract component type from the `Definition.ComponentType` property
3. **Generation**: Generate partial methods that populate the dictionaries

### What Changes

**Before** (manual):
```csharp
private Dictionary<MakaMekComponent, ComponentDefinition> InitializeDefinitions()
{
    return new Dictionary<MakaMekComponent, ComponentDefinition>
    {
        [MakaMekComponent.Shoulder] = ShoulderActuator.Definition,
        [MakaMekComponent.UpperArmActuator] = UpperArmActuator.Definition,
        // ... 46 more manual entries ...
    };
}
```

**After** (generated):
```csharp
// Auto-generated by ComponentProviderGenerator
partial void InitializeGeneratedDefinitions(
    Dictionary<MakaMekComponent, ComponentDefinition> definitions)
{
    definitions[MakaMekComponent.Shoulder] = ShoulderActuator.Definition;
    definitions[MakaMekComponent.UpperArmActuator] = UpperArmActuator.Definition;
    // ... all 48 entries automatically generated ...
}
```

## Edge Cases Handled

### 1. Engine (Dynamic Definition)
**Challenge**: Engine definition is created dynamically based on `EngineStateData`

**Solution**: 
- Skip Engine in definitions dictionary
- Keep manual special case in `GetDefinition()` method
- Include Engine in factories dictionary with validation

### 2. Ammo (One-to-Many Relationship)
**Challenge**: `WeaponDefinition` creates both Weapon and Ammo components

**Solution**:
- Detect `WeaponDefinition.AmmoComponentType` property
- Generate separate entries for weapon and ammo
- Ammo uses `Ammo.CreateAmmoDefinition(WeaponClass.Definition)`

**Example**:
```csharp
// Weapon
definitions[MakaMekComponent.MachineGun] = MachineGun.Definition;
factories[MakaMekComponent.MachineGun] = data => new MachineGun(data);

// Ammo (auto-detected from MachineGun.Definition.AmmoComponentType)
definitions[MakaMekComponent.ISAmmoMG] = Ammo.CreateAmmoDefinition(MachineGun.Definition);
factories[MakaMekComponent.ISAmmoMG] = data => new Ammo(MachineGun.Definition, data);
```

## Developer Experience

### Adding a New Component

**Before** (3 manual steps):
1. Create component class
2. Add to `_definitions` dictionary
3. Add to `_factories` dictionary

**After** (1 step):
1. Create component class with static `Definition` property
   - Build automatically generates mappings ✨

### Example: Adding Gauss Rifle

```csharp
// 1. Add enum values
public enum MakaMekComponent
{
    // ... existing ...
    Gauss,
    ISAmmoGauss
}

// 2. Create component class (following existing pattern)
public sealed class GaussRifle(ComponentData? componentData = null) 
    : Weapon(Definition, componentData)
{
    public static readonly WeaponDefinition Definition = new(
        Name: "Gauss Rifle",
        ElementaryDamage: 15,
        Heat: 1,
        MinimumRange: 2,
        ShortRange: 7,
        MediumRange: 15,
        LongRange: 22,
        Type: WeaponType.Ballistic,
        BattleValue: 320,
        Size: 7,
        FullAmmoRounds: 8,
        WeaponComponentType: MakaMekComponent.Gauss,
        AmmoComponentType: MakaMekComponent.ISAmmoGauss);
}

// 3. Build project - mappings auto-generated! ✅
```

## Benefits

| Benefit | Description |
|---------|-------------|
| **Zero Manual Updates** | No need to touch `ClassicBattletechComponentProvider` when adding components |
| **Compile-Time Validation** | Missing components detected at build time |
| **Type Safety** | Compiler errors if component doesn't follow pattern |
| **Consistency** | All components guaranteed to be registered |
| **Maintainability** | Single source of truth (component classes themselves) |
| **Discoverability** | Easy to see all components by looking at the enum |

## Implementation Effort

| Phase | Estimated Time | Description |
|-------|----------------|-------------|
| 1. Generator Infrastructure | 2-3 hours | Create generator, syntax provider, semantic analysis |
| 2. Ammo Detection | 1-2 hours | Detect and handle WeaponDefinition.AmmoComponentType |
| 3. Code Generation | 2-3 hours | Generate partial methods with proper formatting |
| 4. Provider Refactoring | 1 hour | Convert to partial class, remove manual code |
| 5. Testing & Validation | 2-3 hours | Verify all 48 components, test edge cases |
| 6. Documentation | 1 hour | Update docs, add comments |
| **Total** | **9-13 hours** | Full implementation with testing |

## Risks & Mitigations

| Risk | Likelihood | Mitigation |
|------|------------|------------|
| Generator complexity | Low | Follow existing generator patterns in codebase |
| Build time impact | Low | Use incremental generation (only when components change) |
| Debugging difficulty | Medium | Generate readable code with comments; add diagnostics |
| Edge cases not covered | Low | Comprehensive testing; keep manual override capability |

## Architecture Fit

The codebase is **already well-suited** for this pattern:

✅ **Consistent conventions**: All components follow the same pattern  
✅ **Existing generators**: Two similar generators already in use  
✅ **Static definitions**: Every component has a static `Definition` property  
✅ **Bidirectional mapping**: `Definition.ComponentType` links back to enum  

## Recommendation

**Proceed with implementation.** The benefits far outweigh the implementation cost, and the architecture is already perfectly aligned for this approach.

### Next Steps

1. **Review & Approve**: Get stakeholder approval for the approach
2. **Implement Core**: Build the generator (Phases 1-3)
3. **Test**: Verify with existing 48 components
4. **Refactor**: Update provider class (Phase 4)
5. **Document**: Complete documentation and examples

## Related Documents

- [Detailed Feasibility Analysis](./source-generator-component-mapping-analysis.md) - Full technical analysis
- [Code Examples](./source-generator-component-mapping-examples.md) - Complete code examples and developer workflow
- [Architecture Diagram](#) - Visual representation of the generator flow

## Questions?

**Q: What if I need to add a component that doesn't follow the pattern?**  
A: Keep the manual override capability in the provider class. The generator handles 99% of cases; special cases can still be handled manually.

**Q: Will this slow down builds?**  
A: No. Incremental generators only run when component classes change. Most builds won't trigger regeneration.

**Q: What happens if I forget to add the static Definition property?**  
A: The generator will skip that class and optionally report a diagnostic warning. The component won't be registered, which will be caught in testing.

**Q: Can I still debug the generated code?**  
A: Yes! The generated code is readable C# with comments. You can view it in the IDE and step through it in the debugger.

**Q: What about the Engine special case?**  
A: Engine is handled with a simple check in `GetDefinition()`. The generator skips it in the definitions dictionary but includes it in the factories dictionary with proper validation.

**Q: How does it handle ammo?**  
A: The generator detects `WeaponDefinition.AmmoComponentType` and automatically generates both weapon and ammo mappings. No special handling needed in component classes.

