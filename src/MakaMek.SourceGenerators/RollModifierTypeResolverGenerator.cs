using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Text;

namespace Sanet.MakaMek.SourceGenerators;

[Generator]
public class RollModifierTypeResolverGenerator : ISourceGenerator
{
    public void Initialize(GeneratorInitializationContext context)
    {
        // Register a syntax receiver that will be created for each generation pass
        context.RegisterForSyntaxNotifications(() => new SyntaxReceiver());
    }

    public void Execute(GeneratorExecutionContext context)
    {
        // Get our syntax receiver
        if (context.SyntaxContextReceiver is not SyntaxReceiver receiver)
            return;

        // Get the compilation
        var compilation = context.Compilation;

        // Find the RollModifier type
        var rollModifierSymbol = compilation.GetTypeByMetadataName("Sanet.MakaMek.Core.Models.Game.Mechanics.Modifiers.RollModifier");
        if (rollModifierSymbol == null)
        {
            // Try with a different namespace
            rollModifierSymbol = compilation.GetTypeByMetadataName("Sanet.MakaMek.Core.Models.Game.Mechanics.RollModifier");
            if (rollModifierSymbol == null)
            {
                // If we still can't find it, try to find it by looking at all types
                foreach (var syntaxTree in compilation.SyntaxTrees)
                {
                    var semanticModel = compilation.GetSemanticModel(syntaxTree);
                    var classDeclarations = syntaxTree.GetRoot().DescendantNodes().OfType<ClassDeclarationSyntax>();
                        
                    foreach (var classDeclaration in classDeclarations)
                    {
                        if (classDeclaration.Identifier.Text != "RollModifier") continue;
                        var symbol = semanticModel.GetDeclaredSymbol(classDeclaration);
                        if (symbol == null) continue;
                        rollModifierSymbol = symbol;
                        break;
                    }
                        
                    if (rollModifierSymbol != null)
                        break;
                }
                    
                if (rollModifierSymbol == null)
                    return; // Still couldn't find RollModifier
            }
        }

        // Get the namespace for RollModifier
        var rollModifierNamespace = rollModifierSymbol.ContainingNamespace.ToDisplayString();
            
        // Find all derived classes
        var derivedClasses = new List<INamedTypeSymbol>();
            
        // Check each class in the receiver's list
        foreach (var classSymbol in receiver.CandidateClasses)
        {
            if (InheritsFrom(classSymbol, rollModifierSymbol) && !classSymbol.IsAbstract)
            {
                derivedClasses.Add(classSymbol);
            }
        }
            
        // Generate the source code
        var source = GenerateTypeResolverExtension(rollModifierNamespace, derivedClasses);
            
        // Add the source code to the compilation
        context.AddSource("RollModifierTypeResolverExtension.g.cs", SourceText.From(source, Encoding.UTF8));
    }

    private bool InheritsFrom(INamedTypeSymbol classSymbol, INamedTypeSymbol baseTypeSymbol)
    {
        var currentSymbol = classSymbol.BaseType;
            
        while (currentSymbol != null)
        {
            if (SymbolEqualityComparer.Default.Equals(currentSymbol, baseTypeSymbol))
                return true;
                
            currentSymbol = currentSymbol.BaseType;
        }
            
        return false;
    }

    private string GenerateTypeResolverExtension(string rollModifierNamespace, List<INamedTypeSymbol> derivedClasses)
    {
        var sb = new StringBuilder();
            
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Text.Json.Serialization;");
        sb.AppendLine($"using {rollModifierNamespace};");
            
        // Add imports for all namespaces containing derived classes
        var namespaces = derivedClasses
            .Select(c => c.ContainingNamespace.ToDisplayString())
            .Distinct()
            .Where(ns => ns != rollModifierNamespace)
            .OrderBy(ns => ns);
                
        foreach (var ns in namespaces)
        {
            sb.AppendLine($"using {ns};");
        }
            
        sb.AppendLine();
        sb.AppendLine("namespace Sanet.MakaMek.Core.Services.Transport");
        sb.AppendLine("{");
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Extension for RollModifierTypeResolver with auto-generated derived types");
        sb.AppendLine("    /// Generated automatically by RollModifierTypeResolverGenerator");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    public partial class RollModifierTypeResolver");
        sb.AppendLine("    {");
        sb.AppendLine("        /// <summary>");
        sb.AppendLine("        /// Registers all known RollModifier derived types");
        sb.AppendLine("        /// Generated automatically by RollModifierTypeResolverGenerator");
        sb.AppendLine("        /// </summary>");
        sb.AppendLine("        static partial void RegisterGeneratedTypes(System.Text.Json.Serialization.Metadata.JsonTypeInfo jsonTypeInfo)");
        sb.AppendLine("        {");
        sb.AppendLine("            // Add all known derived types generated by the source generator");
            
        // Add a line for each derived class
        foreach (var derivedClass in derivedClasses.OrderBy(c => c.Name))
        {
            string fullClassName = derivedClass.ToDisplayString();
            string className = derivedClass.Name;
            sb.AppendLine($"            jsonTypeInfo.PolymorphismOptions.DerivedTypes.Add(new JsonDerivedType(typeof({fullClassName}), nameof({className})));");
        }
            
        sb.AppendLine("        }");
        sb.AppendLine("    }");
        sb.AppendLine("}");
            
        return sb.ToString();
    }

    /// <summary>
    /// Syntax receiver that looks for classes that might derive from RollModifier
    /// </summary>
    private class SyntaxReceiver : ISyntaxContextReceiver
    {
        public List<INamedTypeSymbol> CandidateClasses { get; } = new List<INamedTypeSymbol>();

        public void OnVisitSyntaxNode(GeneratorSyntaxContext context)
        {
            // Look for classes
            if (context.Node is not ClassDeclarationSyntax classDeclarationSyntax) return;
            // Get the semantic model for this class
            var semanticModel = context.SemanticModel;
            var classSymbol = semanticModel.GetDeclaredSymbol(classDeclarationSyntax);

            // Add all non-abstract classes that have a base type
            if (classSymbol is { IsAbstract: false, BaseType: not null })
            {
                CandidateClasses.Add(classSymbol);
            }
        }
    }
}